package it.polito.elite.teaching.learnOpenCVBlocks;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.opencv.core.Core;
import org.opencv.core.CvException;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.MatOfFloat;
import org.opencv.core.MatOfInt;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.highgui.Highgui;
import org.opencv.imgproc.Imgproc;









































import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.*;
//OpenCV packages
import javafx.scene.image.Image;
import javafx.scene.layout.Pane;


/**
 * LearnBlock abstract class and interface from which implement new Mat elaboration blocks.
 * <p>
 * FOR PROGRAMMERS
 * See documentation for all functionalities and implementation possibilities.
 * Use stub.java as starting point for creating new blocks structure.
 * <p>
 * FOR USERS: HOW TO USE A LEARNBLOCK
 * You can verify a block in two ways before processing it
 * 1 - setInputMat() + check()		--> returns FALSE if some error occurred, TRUE otherwise
 * 2 - check(input)					--> returns FALSE if some error occurred, TRUE otherwise
 * or you can process it in two ways directly (check() is always called internally!)
 * 1 - setInputMat() + process()	--> returns NULL if some error occurred
 * 2 - process(input)				--> returns NULL if some error occurred
 * In either cases, you can call getError() to get a description of last error occurred!!
 * Use it the way you want!!!!
 * <p>
 * @author	Dario Facchini <io.dariofacchini @ gmail.com>
 * @since	2014-07-01
 */
public abstract class LearnBlock {
	
	//Variables hidden to children classes
	private SimpleBooleanProperty isActive = new SimpleBooleanProperty(true);	//This flag can override (when false) the elaboration of this block, disabling its effects!
	private SimpleBooleanProperty isReady = new SimpleBooleanProperty(false);	//This flag tells if block was successfully able to parse all source files. If not, getError() describes the error!
																				//"FALSE" DOES NOT PREVENT THE BLOCK FROM BEING EXECUTED! Programmer is responsible for risks!
	private SimpleBooleanProperty isValid = new SimpleBooleanProperty(false);	//This flag is AUTOMATICALLY SET and is set to true when a check() is performed successfully!
																				//"FALSE" PREVENTS THE BLOCK FROM RUNNING elaborate()!
	private SimpleBooleanProperty isExecuting = new SimpleBooleanProperty(false);//This flag is "TRUE" only during the "process()". This can be used to know when block begins or ends execution!
	private SimpleBooleanProperty wasModified = new SimpleBooleanProperty(true);//This flag indicates AT LEAST ONE OPTION HAS CHANGED, only then CODE will be reparsed
																				//ATTENTION: interface programmer must implement its way of detecting a change, and then call notifyModification()

	private Mat inputMat = null;				//Last Input Mat used by this block
	private Mat outputMat = null;				//Last Output Mat generated by this block
	private Image inputImg = null;				//An "Image" generated from inpitMat: this variable is used to buffer it when requested by any GUI
	private Image outputImg = null; 			//An "Image" generated from outputMat: this variable is used to buffer it when requested by any GUI
	static private Image nullImg = null;		//A user-friendly standard Image loaded ONCE that is displayed when either inputMat or outputMat are null
	
	private GuiParser guiElements;				//This internal class manages GUI Controls
	private String fxmlPath;
	private String docPath;
	private String codBasePath;
	private boolean fxmlLoaded = false;
	private boolean docLoaded = false;
	private boolean codLoaded = false;
	
	//Each block is allowed to have MULTIPLE VERSIONS of algorithms.
	//If any, each version must be written separately in "code" dir with pattern [blockname][version_num].txt
	//Programmer MUST IMPLEMENT the conditions or input combinations that trigger the change:
	//	- validate(): writing custom if/else or switch/case that MUST set "codeVersion" accordingly (from 0 to N)
	//	- elaborate(): implement all versions and use if/else or switch/case on "codeVersion" to separate them
	//WARNING: default value is zero. Also if you have ONLY ONE version, code file must be named blockname0.txt!
	protected int codeVersion = 0;
	private int lastCodeVersion = -1;			//a new render of the code must be done if version changes
	
	private String thisBlockName = this.getClass().getSimpleName();
	private String thisBlockDescription;
	private List<String> thisBlockSymbolicCode;
	private String thisBlockRenderedCode;
	
	//CODE PARSING PATTERN: match single word between <[]> ignoring left-side or right-side spaces
	//TEST: private static final Pattern TAG_REGEX = Pattern.compile("(<[\\s*)([^\\d]\\w+)(\\s*]>)");
	private static final Pattern TAG_REGEX = Pattern.compile("<!\\s*(\\w+)\\s*>");
    private ObservableList<String> orderedTagNames = null;
    
	//Variables accessible from children classes
	protected String error;							//Children can set a descriptor string here, if some error occurred


	/**
	 * Contructor: do some checks, report state and prevent block from loading if fxml fails
	 */
	public LearnBlock()
	{
				
		this.fxmlPath = "fxml/" + thisBlockName + ".fxml";
		this.docPath = "des/" + thisBlockName + ".txt";
		this.codBasePath = "cod/";
		
		guiElements = new GuiParser();
		
		loadFXML();	
		loadDescription();
		//to call AFTER FXML is loaded
		loadCode();
		
		//This variable will tell if block was loaded correctly
		isReady.set(checkLoading());

		//Try to load a standard nullmatrix Image if not already done (from package learnOpenCV/img)
		//Every time Mat2Image is executed with a null input, it will return nullImg instead.
		if(nullImg == null)
		{
			try
			{
				//System.out.println(getClass().getResource("../learnOpenCV/img/nullmatrix.png").getPath());
				File stdNullImg = new File( getClass().getResource("../learnOpenCV/img/nullmatrix.png").getPath() );
				String stdNullImgPath = stdNullImg.getAbsolutePath().toString();
				Mat stdNullImgMat = Highgui.imread( stdNullImgPath );
				nullImg = Mat2Image(stdNullImgMat);
				inputImg = nullImg;
				outputImg = nullImg;
			}
			catch (Exception ex)
			{
				//ex.printStackTrace();
				//Nothing happens if image is not found
			}
		}
		
	}
	
	
////////////////////////////////////
// Class for GUI elements parsing
////////////////////////////////////
	/**
	 * @author Dario Facchini
	 * 
	 * This inner class contains the gui physical elements of LearnBlock plus methods to push/pop them
	 */
	public class GuiParser
	{
		private Parent root = null;					//Root of block FXML control elements is loaded here: it is useful to rearrange them from outside
		private ObservableList<Parent> blockOrderedComponents = null;
		private ObservableList<Control> blockOrderedControls = null; 
		
		
		/**
		 * Get the original graphic ROOT node used for this GUI
		 * 
		 * You can move this node wherever you need so no fear, but just remember:
		 * 	- if you set the root to null, no restoreControls() will be possible
		 * 	- if you set the root to some other node, restoreControls() will restore the controls to the new node
		 * 	- if you move nodes manually from inside root to somewhere else, remember to call restoreControls()
		 * Anyway, getControls() will always work! :)
		 * 
		 * @return generic Parent root
		 */
		public Parent getRoot()
		{
			if(root == null)
			{
				System.out.print("FXML was not loaded! Reloading...");
				loadFXML();
			}
			return root;
		}

		//
		/**
		 * Get an observable ORDERED read-only list of Control nodes (from first to last argument defined in code file)
		 * See the programmer's documentatio for details. This method cannot be used if no code is available.
		 * You can then move those nodes wherever you need to.
		 * @return 
		 */
		public ObservableList<Parent> getControls()
		{
			ObservableList<Parent> blockReadOnlyOrderedComponents = FXCollections.unmodifiableObservableList(blockOrderedComponents);
			return blockReadOnlyOrderedComponents;
		}
		

		/**
		 * Restore list of Control nodes where they were originally
		 * Call this ONLY IF nodes where moved, otherwise will return FALSE (manages the duplicate-children exception..)
		 * @return
		 */
		public boolean restoreControls()
		{
			boolean couldBeRestored = false;
			if( !blockOrderedComponents.isEmpty() && root!=null )
			{
				try
				{
					
					couldBeRestored = ((Pane)root).getChildren().addAll(blockOrderedComponents);
				}
				catch(IllegalArgumentException e)
				{
					error=e.toString() + "\nNote: you have to call getControls() and move the nodes somewhere else before calling restoreControls()";
				}
			}
			else
			{
				error="No valid Controls could be found from FXML";
			}
			
			return couldBeRestored;
		}
		

		/**
		 * Basically, this is a getControls() which will also put Control nodes in a container of your choice
		 * This is faster but.. it will add them all in sequence (suitable for an Hbox, Vbox.. not for a GridPane)
		 * @param newContainer Parent to which insert Components 
		 * @return
		 */
		public boolean popControlsTo(Parent newContainer)
		{
			boolean couldBeInserted = false;
			
			if(!blockOrderedComponents.isEmpty())
			{
				newContainer.getChildrenUnmodifiable().addAll(blockOrderedComponents);
				couldBeInserted = true;
			}
			else
			{
				error="No valid Controls could be found from FXML";
			}
			
			return couldBeInserted;
		}



	}


////////////////////////////////////
// Methods that MUST BE overridden
////////////////////////////////////
	
	/**
	 * This functions must check if the elaborate may be performed. An "inputMat" can be given for analizing all checks
	 * See programmer's documentation for details.
	 *  
	 * @param input Mat which won't be modified
	 * @return boolean The result of validation
	 */
	protected abstract boolean validate(final Mat input);
	
	/**
	 * This functions must perform the Block elaboration.
	 * "input" is a CLONE of "inputMat", so this function must not necessary create new Mat()
	 * See programmer's documentation for details.
	 * 
	 * @param input Mat to be processed
	 * @return Mat as the result of elaboration
	 */
	protected abstract Mat elaborate(Mat input);


////////////////////////////////////
// Methods TO NOT override
////////////////////////////////////

	// SET AND ELABORATE
	/////////////////////

	/**
	 * Call this method manually if you want to know if there is some error on fxml, description, code loading
	 * If there is, call getError() to get into details
	 * @return boolean True if all checks are true
	 */
	public boolean checkLoading()
	{
		if(!fxmlLoaded)
		{
			error="Parsing error on fxml! This block CANNOT be loaded/used correctly!";
			return false;
		}
		else if(!docLoaded)
		{
			error="Loading error on description! File may be absent. This block's description will not be displayed.";
			return false;
		}
		else if(!codLoaded)
		{
			error="Parsing error on code! Code may be absent or block fxml implementation differs from declared code. Please check for syntax errors also. Code won\'t be rendered for this block.";
			return false;
		}
		else
		{
			return true;
		}
	}
	
	/**
	 * Call this method to signal that block setting have been modified since last process() call
	 * <p>
	 * EXAMPLE:
	 * In original program, this is called by MainWindowGUI when user interacts with graphic elements of the block
	 * LearnBlockGUI can then call getModifiedProperty to change led status accordingly
	 */
	public void notifyModification()
	{
        wasModified.set(true);
	}
	
	/**
	 * Set an inputMat for checking and processing
	 * If not done here, it must be done on process() call as argument
	 * 
	 * @param input
	 */
	public void setInputMat(Mat input)
	{
		inputMat = input;
	}
	
	/**
	 * Resets block state for a fresh start (resets state but does not reload files!)
	 */
	public void reset()
	{
		error="";
		lastCodeVersion = -1;
		codeVersion = 0;
		inputMat = null;
		outputMat = null;
		inputImg = nullImg;
		outputImg = nullImg;
	}
	
	/**
	 * Perform a check() with the last inputMat set
	 * WARNING: check ALWAYS FAILS if no inputMat was set!!
	 * <p>
	 * See documentation for details.
	 * 
	 * @return boolean True only if all available checks are true
	 */
	public boolean check()			//make a check WITHOUT processing, considering LAST inputMat processed
	{
		error="";					//flush last error content
		
		try
		{
			isValid.set( validate(inputMat) );		//validate() input is last set inputMat
		} catch (NullPointerException e)
		{
			// If validate() terminates because of null inputMat, nothing is thrown.
			// Any error reported until termination can still be displayed!
			// If validate() is correctly implemented, no exception should be thrown and
			// error should contain at least errors independent from input Mat (if any)
		}
		
		// To be safe, when inputMat is null, result of validate is ignored, but
		// all errors reported so far will still be present, plus an info string explaining
		// the final user why validation cannot be fully successful
		if(inputMat == null)
		{
			isValid.set(false);
			error+=" - Warning: null input Mat is currently set, a valid input is required to get full validation";
		}
		return isValid.get();
	}
	
	/**
	 * Set a new inputMat and perform a check() 
	 * 
	 * @param input Mat
	 * @return boolean True only if all available checks are true
	 */
	public boolean check(Mat input)
	{
		inputMat = input;
		return check();
	}
	
	/**
	 * Gets the output mat of this block, ONLY if inputMat has been set
	 * - makes an explicit call to elaborate only if necessary (isActive flag true)
	 * - converts also the output mat in "Image"
	 * - if the output is null, Image returned is a special image (nullmatrix.png) or null if file is not found
	 * WARNING: check() is performed automatically, if check() fails process will return a null Mat
	 * <p>
	 * See documentation for details.
	 * 
	 * @return Mat A valid result (that can be processed by other blocks)
	 */
	public Mat process()
	{	
		inputImg = null;				//reset buffered Images: they will be newly allocated during process
		outputImg = null;
		
		if( isActive.get())				//N.B. when block is overridden the block DOES NOT EXECUTE at all!
		{			
			wasModified.set(false);		//reset modified state each time user TRIES to process this block
			isExecuting.set(true);		//HERE BEGINS BLOCK EXECUTION
			if( check() )
			{
				try
				{
					outputMat = elaborate(inputMat.clone());	//a clone() is ALWAYS performed in order to:
																//-	preserve user's input
																//-	keep track of last input for research reasons..
					
					renderCode();								//force a new render of the code
				}
				catch (CvException e)
				{
					outputMat=null;
					error="Unhandled OpenCV exception: "+e.getMessage()+"";
				}
			}
			else outputMat = null;		//if validation for this block failed, return null!
			//Overwrite all errors raised by check() if input of process was null in the first place!!
			if(inputMat==null) error="No valid input set to process (null matrix)";
			isExecuting.set(false);		//HERE ENDS BLOCK EXECUTION
		}
		else
		{
			outputMat = inputMat;		//override elaboration if isActive flag is disabled or input is null (can be errors in previous blocks!)
		}
		
		inputImg = Mat2Image(inputMat);
		outputImg = Mat2Image(outputMat);
		
		return outputMat;
	}
	
	/**
	 * Sets an input mat and then call process() on it
	 * WARNING: check() is performed automatically by process(), if something went wrong it returns null
	 * See process() for more details
	 * 
	 * @param input Mat
	 * @return Mat A valid result (that can be processed by other blocks)
	 */
	public Mat process(Mat input)
	{
		inputMat = input;				//set new inputMat for this block (it is set ONLY when process is called)
		return process();
	}

	
	
	
	
	// GETTER
	///////////
	
	/**
	 * Get description of this block as a String
	 * 
	 * @return String
	 */
	public String getDescription()
	{
		return thisBlockDescription;
	}
	
	/**
	 * Returns instance of container of graphics for this block
	 * 
	 * @return GuiParser
	 */
	public GuiParser getGui()
	{
		return guiElements;
	}

	/**
	 * Returns ActiveProperty for external binding.
	 * This flag can override (when false) the elaboration of this block, disabling its effects!
	 * <p>
	 * See documentation for LearnBlock behaviour details
	 * 
	 * @return BooleanProperty
	 */
	public BooleanProperty getActiveProperty()
	{
		return isActive;
	}

	/**
	 * Returns ReadyProperty for external binding.
	 * This flag tells if block was successfully able to parse all source files. If not, getError() describes the error!
	 * "FALSE" DOES NOT PREVENT THE BLOCK FROM BEING EXECUTED! Programmer is responsible for risks!
	 * <p>
	 * See documentation for LearnBlock behaviour details
	 * 
	 * @return BooleanProperty
	 */
	public BooleanProperty getReadyProperty()
	{
		return isReady;
	}

	/**
	 * This flag is AUTOMATICALLY SET and is set to true when a check() is performed successfully!
	 * "FALSE" PREVENTS THE BLOCK FROM RUNNING elaborate()!
	 * <p>
	 * See documentation for LearnBlock behaviour details
	 * 
	 * @return BooleanProperty
	 */
	public BooleanProperty getValidProperty()
	{
		return isValid;
	}

	/**
	 * This flag is "TRUE" only during the "process()".
	 * This can be used to know when block begins or ends execution!
	 * <p>
	 * See documentation for LearnBlock behaviour details
	 * 
	 * @return BooleanProperty
	 */
	public BooleanProperty getExecutingProperty()
	{
		return isExecuting;
	}
	
	/**
	 * This flag indicates AT LEAST ONE SETTING HAS CHANGED, so that only then CODE will be reparsed
	 * ATTENTION: interface programmer must implement its own way of detecting a change, and then call notifyModification()
	 * <p>
	 * See documentation for LearnBlock for details
	 * 
	 * @return BooleanProperty
	 */
	public BooleanProperty getModifiedProperty()
	{
		return wasModified;
	}
	
	/**
	 * Returns current input for this block
	 * 
	 * @return Mat
	 */
	public Mat getInputMat()
	{
		return inputMat;
	}
	
	/**
	 * Get a copy of the current output for this block (its a clone, so that block keeps a copy for itself)
	 * 
	 * @return Mat
	 */
	public Mat getOutputMat()
	{
		if(outputMat!=null) return outputMat.clone();
		else return null;
	}

	/**
	 * Returns current input for this block as an Image
	 * Will return a special image (nullmatrix.png if found) or null if output matrix is null.
	 * See process() method details.
	 * 
	 * @return Image
	 */
	public Image getInputImage()
	{
		return inputImg;
	}
	
	/**
	 * Returns current output for this block as an Image
	 * Will return a special image (nullmatrix.png if found) or null if output matrix is null.
	 * See process() method details.
	 * 
	 * @return Image
	 */	
	public Image getOutputImage()
	{
		return outputImg;
	}

	/**
	 * Returns a graphical histogram of current output, at a default dimension of 1280x960
	 * 
	 * @return Image
	 */
	public Image getOutputHistogram()
	{
		return Mat2Histogram(outputMat);
	}
	
	/**
	 * Returns a graphical histogram of current output, at a specified dimension
	 * 
	 * @param width
	 * @param height
	 * @return Image
	 */
	public Image getOutputHistogram(final int width, final int height)
	{
		return Mat2Histogram(outputMat, width, height);
	}
	
	/**
	 * Returns a graphical representation of fourier tranform of current output, at its same dimension
	 * 
	 * @return Image
	 */
	public Image getOutputFourier()
	{
		return Mat2Fourier(outputMat);
	}
	
	/**
	 * Get a description of last error encountered by the block.
	 * error is flushed ad each process()/check() call
	 * 
	 * @return String
	 */
	public String getError()
	{
		return error;
	}
	
	/**
	 * Gets this block's name
	 * 
	 * @return String
	 */
	public String getName()
	{
		return thisBlockName;
	}
	
	/**
	 * Call this function everytime you need a refreshed code (this will refresh values in text too)
	 * Code is independent from output, but dependent on current block's settings.
	 * Code will then be regenerated on scratch:
	 * - automatically, after each process()
	 * - manually, if codeVersion has changed or notifyModification() has been previously called
	 * 
	 * @return String
	 */
	public String getCode()
	{
		if(wasModified.get() || lastCodeVersion!=codeVersion)
		{
			renderCode();				//force a new render of the code if some controls were modified or codeVersion has changed
		}
		return thisBlockRenderedCode;	
	}

	
	
	
	
	// UTILS
	///////////

	/**
	 * CONVERTS MAT (opencv.core.Mat image data) TO IMAGE (compatible with JavaFX)
	 * "Mat" must be converted in pure bytes of an image file to be opened by "Image" constructor
	 * 1- Mat (specific class to manage image) -> MatOfBytes (Mat extension that manages image as different structures)
	 * 2- MatOfBytes -> Array (it can be used as an input stream!)
	 * 3- Array -> ByteArrayInputStream (this way we can read the Array as it was data on the disk)
	 * 
	 * @param input Mat
	 * @return Image - nullmatrix.png or null if input Mat is null
	 */
	public static Image Mat2Image(final Mat input)
	{
		if(input!=null)
		{
			// create a temporary buffer
			MatOfByte buffer = new MatOfByte();
			// encode the frame in the buffer
			Highgui.imencode(".png", input, buffer);
			// build and return an Image created from the image encoded in the
			// buffer
			return new Image(new ByteArrayInputStream(buffer.toArray()));			
		}
		else return nullImg;
	}
	
	/**
	 * Generates an Image version of histogram of an input Mat
	 * 
	 * @param input
	 * @param width
	 * @param height
	 * @return Image
	 */
	public static Image Mat2Histogram(final Mat input, final int width, final int height)
	{
		
		if(input!=null)
		{
			Mat toElaborate = new Mat();
			input.copyTo(toElaborate);
	
			input.convertTo(toElaborate, CvType.CV_16U);
			
			
			
			if(toElaborate.channels() == 1)
			{
				
				Imgproc.cvtColor(toElaborate, toElaborate, Imgproc.COLOR_GRAY2BGR);
				
				
			}
			
			List<Mat> images = new ArrayList<Mat>();
	
			// set the number of bins at 256
			MatOfInt histSize = new MatOfInt(256);
			// only one channel
			MatOfInt channels = new MatOfInt(0);
			// set the ranges
			MatOfFloat histRange = new MatOfFloat(0, 256);
	
			// compute the histograms for the B, G and R components
			Mat hist_b = new Mat();
			Mat hist_g = new Mat();
			Mat hist_r = new Mat();
	
			// draw the histogram
			int hist_w = width; // width of the histogram image
			int hist_h = height; // height of the histogram image
			int bin_w = (int) Math.round(hist_w / histSize.get(0, 0)[0]);
			Mat histImage = new Mat(hist_h, hist_w, CvType.CV_8UC3, new Scalar(0,
					0, 0));
	
			Core.split(toElaborate, images);
			Imgproc.calcHist(images.subList(0, 1), channels, new Mat(), hist_b,
					histSize, histRange, false);
			Imgproc.calcHist(images.subList(2, 3), channels, new Mat(), hist_r,
					histSize, histRange, false);
			Imgproc.calcHist(images.subList(1, 2), channels, new Mat(), hist_g,
					histSize, histRange, false);
	
			Core.normalize(hist_b, hist_b, 0, histImage.rows(), Core.NORM_MINMAX,
					-1, new Mat());
			Core.normalize(hist_r, hist_r, 0, histImage.rows(), Core.NORM_MINMAX,
					-1, new Mat());
			Core.normalize(hist_g, hist_g, 0, histImage.rows(), Core.NORM_MINMAX,
					-1, new Mat());
	
			for (int i = 1; i < histSize.get(0, 0)[0]; i++) {
				Core.line(
						histImage,
						new Point(bin_w * (i - 1), hist_h
								- Math.round(hist_b.get(i - 1, 0)[0])),
						new Point(bin_w * (i), hist_h
								- Math.round(hist_b.get(i, 0)[0])), new Scalar(255,
								0, 0), 1, 8, 0);
				Core.line(
						histImage,
						new Point(bin_w * (i - 1), hist_h
								- Math.round(hist_r.get(i - 1, 0)[0])),
						new Point(bin_w * (i), hist_h
								- Math.round(hist_r.get(i, 0)[0])), new Scalar(0,
								0, 255), 1, 8, 0);
				Core.line(
						histImage,
						new Point(bin_w * (i - 1), hist_h
								- Math.round(hist_g.get(i - 1, 0)[0])),
						new Point(bin_w * (i), hist_h
								- Math.round(hist_g.get(i, 0)[0])), new Scalar(0,
								255, 0), 1, 8, 0);
			}
	
			Image toshow = Mat2Image(histImage);
	
			return toshow;
		}
		else return null;
		
	}
	
	/**
	 * Generates an Image version of histogram of an input Mat at standard resolution of 1280x960
	 * 
	 * @param input
	 * @return Image
	 */
	public static Image Mat2Histogram(final Mat input)
	{
		return Mat2Histogram(input,1280,960);
	}
	
	/**
	 * Generates an Image version of histogram of an input Mat with the same dimension
	 * 
	 * @param input
	 * @return Image
	 */
	public static Image Mat2Fourier(Mat input)
	{
		
		if(input!=null)
		{
			Mat toTransform = new Mat();
			List<Mat> planes = new ArrayList<>();
			Mat complexImage = new Mat();;
			
			
			input.convertTo(toTransform, CvType.CV_16U);
			
			
	
			if(toTransform.channels() == 3)
			{
			
				Imgproc.cvtColor(toTransform, toTransform, Imgproc.COLOR_BGR2GRAY);
				
				
			}
			
			
			
			
			
			
			
			// init
			Mat padded = new Mat();
			// get the optimal rows size for dft
			int addPixelRows = Core.getOptimalDFTSize(toTransform.rows());
			// get the optimal cols size for dft
			int addPixelCols = Core.getOptimalDFTSize(toTransform.cols());
			// apply the optimal cols and rows size to the image
			Imgproc.copyMakeBorder(toTransform, padded, 0, addPixelRows
					- toTransform.rows(), 0, addPixelCols - toTransform.cols(),
					Imgproc.BORDER_CONSTANT, Scalar.all(0));
	
			padded.convertTo(padded, CvType.CV_32F);
			planes.add(padded);
			planes.add(Mat.zeros(padded.size(), CvType.CV_32F));
			// prepare a complex image for performing the dft
			Core.merge(planes, complexImage);
			// dft
			// complexImage.convertTo(complexImage, CvType.CV_64FC2);
			Core.dft(complexImage, complexImage);
	
			List<Mat> newPlanes = new ArrayList<>();
			Mat mag = new Mat();
			// split the comples image in two planes
			Core.split(complexImage, newPlanes);
			// compute the magnitude
			Core.magnitude(newPlanes.get(0), newPlanes.get(1), mag);
	
			// move to a logarithmic scale
			Core.add(mag, Scalar.all(1), mag);
			Core.log(mag, mag);
	
			mag = mag.submat(new Rect(0, 0, mag.cols() & -2, mag.rows() & -2));
			int cx = mag.cols() / 2;
			int cy = mag.rows() / 2;
	
			Mat q0 = new Mat(mag, new Rect(0, 0, cx, cy));
			Mat q1 = new Mat(mag, new Rect(cx, 0, cx, cy));
			Mat q2 = new Mat(mag, new Rect(0, cy, cx, cy));
			Mat q3 = new Mat(mag, new Rect(cx, cy, cx, cy));
	
			Mat tmp = new Mat();
			q0.copyTo(tmp);
			q3.copyTo(q0);
			tmp.copyTo(q3);
	
			q1.copyTo(tmp);
			q2.copyTo(q1);
			tmp.copyTo(q2);
	
			Core.normalize(mag, mag, 0, 255, Core.NORM_MINMAX);
			// planes=new ArrayList<>();
			// complexImage = new Mat();
	
			Image toshow = Mat2Image(mag);
	
			return toshow;
		}
		else return null;
		
	}
	
	
	
	
	
	// LOADING
	///////////	
	
	/**
	 * Loads GUI elements for this block (.fxml defined by the block developer)
	 * <p>
	 * SEE PROGRAMMER'S DOCUMENTATION FOR IMPLEMENTATION DETAILS!
	 */
	private void loadFXML()
	{
		//Initiate a new loader associated with the fxml document containing the style (it will convert fxml in objects)
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource( fxmlPath ));
		fxmlLoader.setController(this);
		//Load() structure and populate HBox from the loader
		try {
			guiElements.root = (Parent)fxmlLoader.load();
		} catch (IOException e)
		{
			// Do not allow the block to be instantiated if fxml loading fails!
			fxmlLoaded=false;
			throw new RuntimeException(e);
			
		}

		
		
		// INSTANCIATE ORDERED LIST OF BLOCK GUI COMPONENTS (Control containers) for future use
		//Parse control containers (only the ones with id="control" or fx:id="control"!)
		Set<Node> blockControls = guiElements.root.lookupAll("#control");
		//GRAPHICAL DISPLAY ORDER OF COMPONENTS IN ROOT MAY DIFFER FROM ORDER DEFINED IN THIS LIST!!! 
		//typically, for a linear fxml structure, the components will follow the order defined in text BUT ORDER IS NOT GUARANTEED
		guiElements.blockOrderedComponents = FXCollections.observableArrayList();
		for(Node node : blockControls)
		{
			//as documented, LearnBlock will assume nodes with id="control" or fx:id="control" to be CONTAINERS!
			guiElements.blockOrderedComponents.add((Parent)node);
		}

		
		fxmlLoaded=true;
		
	}
		
	/**
	 * Load Description for this block (.txt defined by the block developer)
	 * <p>
	 * SEE PROGRAMMER'S DOCUMENTATION FOR IMPLEMENTATION DETAILS!
	 */
	private void loadDescription()
	{
		//Catch description text from file
		Scanner scanner = null;
		thisBlockDescription="";
		try
		{
			File file=new File( getClass().getResource(docPath).getPath() );
			scanner = new Scanner(file);
			while (scanner.hasNextLine())
			{
				thisBlockDescription += scanner.nextLine()+"\n";
			}
		}
		catch (Exception ex)
		{
			docLoaded=false;
			return;
			//throw new RuntimeException(ex);
		}
		finally
		{
			if (scanner != null) scanner.close();
		}
		
		docLoaded=true;
		
	}

	/**
	 * Load Symbolic Code for this block (.txt defined by the block developer)
	 * <p>
	 * SEE PROGRAMMER'S DOCUMENTATION FOR IMPLEMENTATION DETAILS!
	 */
	private void loadCode()
	{
		
		codLoaded=false;
		
		if(fxmlLoaded)
		{
			
			thisBlockSymbolicCode = new ArrayList<String>();
			final List<String> tagNames = new ArrayList<String>();		//this will contain ALL UNIQUE tag names found in the code files!
			
			//LOOP for searching and loading multiple versions of code (version is incremented until a file is not found)
			boolean noMoreVersionsFound = false;	//this will stop the loop (next file is not found)
			int nextVersion = 0;
			System.out.println("Finding tags in code files...");
			while(!noMoreVersionsFound)
			{
				Scanner scanner = null;
				try
				{
					//Try to load the file for "nextVersion"
					File file=new File( getClass().getResource(codBasePath + thisBlockName + nextVersion +".txt").getPath() );
					scanner = new Scanner(file);
					String currentfile = new String();
					while (scanner.hasNextLine())
					{
						currentfile += scanner.nextLine()+"\n";
					}
					
					//Add it to collection of all code versions
					thisBlockSymbolicCode.add( new String(currentfile) );
					
					//Parse tag names and keep just their first global occurrence (format: <[arg]>)
					final Matcher matcher = TAG_REGEX.matcher(thisBlockSymbolicCode.get(nextVersion));
				    while (matcher.find()) {
				    	if( !tagNames.contains(matcher.group(1)) )
				    	{
				    		tagNames.add(matcher.group(1));	//group=2 will fetch the second () in REGEX, which is tag content in our case!
				    		System.out.println(matcher.group(1));
				    	}   
				    }
				    
				    //No exception occurred: ready for parsing next file
					nextVersion++;
				    
				} catch (Exception e) {
					noMoreVersionsFound=true;
				}
				finally
				{
					if (scanner != null) scanner.close();
				}

			}
			

		    //** CHECK OVERALL ARGUMENTS CORRESPONDENCE BETWEEN CODE AND FXML AND REORDER THEM **//
		    //RULE: excluding special INPUT and OUTPUT, code can contain as many different tags as IDs defined in the fxml (but not more!)	    
		    int inputIndex = tagNames.indexOf("INPUT");
		    int outputIndex = tagNames.indexOf("OUTPUT");
		    //ONLY IF:
		    //	1) at least "INPUT" and "OUTPUT" tags were found in code.txt file you can continue with parsing...
		    //	2) number of tagNames found in different codes (excluding "INPUT" and "OUTPUT") is EQUAL to number of Components in fxml
		    //OTHERWISE "codLoaded" WILL STAY FALSE!
		    if( inputIndex!=-1 && outputIndex!=-1 && tagNames.size()-2 == guiElements.blockOrderedComponents.size() )
		    {
		    	//1 - REMOVE first two constant arguments ("INPUT" and "OUTPUT") from tagNames list
		    	tagNames.remove(tagNames.indexOf("INPUT"));
		    	tagNames.remove(tagNames.indexOf("OUTPUT"));
			    
			    //2 - CREATE arrays for ordered tagNames and Controls (NOTE: "tagNames" now NO longer contains INPUT and OUTPUT)
		    	String[] orderedTagNamesArray = new String[tagNames.size()];
			    Control[] blockOrderedControlsArray = new Control[tagNames.size()];
			    System.out.println( "Expected a total of " + tagNames.size() + " Controls in the FXML file");
			    
			    //3 - ORDER tagNames and Controls following THE SAME ORDER they appear in the FXML tree defined by the Block programmer
			    codLoaded = true;
			    for(String controlTag : tagNames)
				{
					boolean controlFound = false;
					int currentIndex=0;
					while( !controlFound && currentIndex < guiElements.blockOrderedComponents.size() )
					{
						Node innerControl = guiElements.blockOrderedComponents.get(currentIndex).lookup("#"+controlTag);
						System.out.print( "Searching \"" + controlTag + "\" in Component " + currentIndex + " of fxml -> ");
						if(innerControl!=null && innerControl instanceof Control)
						{
							controlFound = true;
							//orderedTagNamesArray[currentIndex+2] = controlTag;
							orderedTagNamesArray[currentIndex] = controlTag;
							blockOrderedControlsArray[currentIndex] = (Control) innerControl;
							System.out.println( "Found!\nI put it in position [" + (currentIndex) + "] of total Components.");
						}
						else
						{
							System.out.println("Not found...");
						}
						currentIndex++;
					}
					//if for only one tag we did not found an id in fxml, whole parsing must fail!
					if( !controlFound ) codLoaded = false;
				}
			    
			    
			    //Print overall summary
			    if(codLoaded) 	System.out.println("--> Code loading/parsing process SUCCEDED. All tags were found in fxml and all id have an occurrence in at least one code.");
			    else			System.out.println("--> Code loading/parsing process FAILED. Tags total number is OK but some have no correspondence to id/fx:id in FXML file. Please check!");
			    
			    
			    // INSTANCIATE OBSERVABLE ORDERED LIST OF TAGS for future use
			    orderedTagNames = FXCollections.observableArrayList( Arrays.asList(orderedTagNamesArray) );
			    
				// INSTANCIATE OBSERVABLE ORDERED LIST OF BLOCK GUI CONTROLS (Graphical Control Nodes) for future use
			    guiElements.blockOrderedControls = FXCollections.observableArrayList( Arrays.asList(blockOrderedControlsArray) );
			    
		    }
		    else
		    {
		    	System.out.println("--> Code loading/parsing process FAILED. No code found OR no INPUT or OUTPUT were found in any code OR total tags are more or less than fxml components!");
		    }
	    }


		
	}

	/**
	 * Ultimately generates a Rendered Code from loaded Symbolic Code with current block settings values.
	 * Rules on which text values are chosen depend on fxml elements.
	 * <p>
	 * SEE PROGRAMMER'S DOCUMENTATION FOR IMPLEMENTATION DETAILS! 
	 */
	private void renderCode()
	{
		
		if(fxmlLoaded && codLoaded)
		{
			//Preparing new render of symbolic text to be baked with current values
			thisBlockRenderedCode = new String(thisBlockSymbolicCode.get(codeVersion));
			lastCodeVersion = codeVersion;
			
			
			//Standard/static text parsing for testing
			//thisBlockRenderedCode.replaceAll( "<!\\s*(INPUT)\\s*>" , "inputMat");
			//thisBlockRenderedCode.replaceAll( "<!\\s*(OUTPUT)\\s*>" , "outputMat");
			
			
			//Text rendering of Controls value
			int currentTagIndex = 0;
			for(String tag : orderedTagNames)
			{
				Control control = guiElements.blockOrderedControls.get(currentTagIndex);
				
				//Support for Boolean Input Controls ("true" or "false" will be printed)
				if		( control instanceof CheckBox )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , String.valueOf( ((CheckBox)control).isSelected() ) );
				else if ( control instanceof RadioButton )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , String.valueOf( ((RadioButton)control).isSelected() ) );
				else if ( control instanceof ToggleButton )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , String.valueOf( ((ToggleButton)control).isSelected() ) );
				
				//Support for Indexer Input Controls
				else if ( control instanceof ComboBox )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , String.valueOf( ((ComboBox)control).getSelectionModel().getSelectedItem() ) );
				else if	( control instanceof ChoiceBox )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , String.valueOf( ((ChoiceBox)control).getSelectionModel().getSelectedIndex() ) );
				else if ( control instanceof ListView )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , String.valueOf( ((ListView)control).getSelectionModel().getSelectedItem() ) );

				//Support for Real-time Value Input Controls
				else if ( control instanceof ScrollBar )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , String.valueOf( ((ScrollBar)control).getValue() ) );
				else if ( control instanceof Slider )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , String.valueOf( ((Slider)control).getValue() ) );
				
				//Support for Manual Value / Text Input Controls
				else if	( control instanceof TextField )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , ((TextField)control).getText() );
				else if	( control instanceof TextArea )
					thisBlockRenderedCode = thisBlockRenderedCode.replaceAll( "<!\\s*(" + tag + ")\\s*>" , ((TextArea)control).getText() );
				
				currentTagIndex++;
			}
		}
		
				
	}

	
}